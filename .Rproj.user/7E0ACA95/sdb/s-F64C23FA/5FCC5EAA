{
    "contents" : "#' Function for the method of Independent Evolution\n#'\n#' This function allows computing rescaled branch lengths according to inferred phenotypic evolution and ancestral states using the method of Independent Evolution as described in Smaers & Vinicius (2009)\n#' @param data numeric vector with elements in the same order as tiplabels in the tree\n#' @return dataframe with rescaled branch lengths (rBL) for all branches in the tree\n#' @details This function poses the following restrictions on the input data: no polytomies in the tree, no duplicated values, no zero values, and no negative values in the data. The algorithm was designed to deal with linear data (unlogged). \n#' @export\n\nie<-function(data,tree){\ndata_original<-data\n            N=length(data)\n      #Make phylo matrix and list nodes\n            matrix=tree$edge\n            phy.matrix=data.frame(tree$edge,tree$edge.length,data[matrix[,2]])\n            names(phy.matrix)=c(\"Anc\",\"Desc\",\"Length\",\"Value\")\n            phy.matrix.length=nrow(phy.matrix)\n            nodes_extant=1:N\n            nodes_extinct=(N+1):(N+(N-1))\n            nodes_all=1:(N+(N-1))\n\n\n#CODE\n\n#1. CALCULATE AP BRANCH LENGTHS\n            matrix_lengths=dist.nodes(tree)\n#2. CALCULATE AP-values\n\n      values=phy.matrix$Value[which(phy.matrix$Desc<=N)]\n      extant_values=data.frame(values,nodes_extant)\n\n      AP_values=c()\n\n      for(j in nodes_extinct){\n            #calculate nominator\n                  nominator=c()\n                        for(i in nodes_extant){\n                              nominator=rbind(nominator,(extant_values[i,1]/matrix_lengths[i,j]))\n                                              }\n            #calculate denominator\n                  denominator=c()\n                        for(i in nodes_extant){\n                              denominator=rbind(denominator,(1/matrix_lengths[i,j]))\n                                              }\n            #save AP\n                  AP=sum(nominator)/sum(denominator)\n                  AP_values=rbind(AP_values,AP)\n                             }\n\n      AP=c()\n      AP=cbind(AP,AP_values)\n      AP=cbind(AP,nodes_extinct)\n      AP=as.data.frame(AP)\n      colnames(AP)=c(\"value\",\"nodes\")\n\n#3. CALCULATE ANCESTRAL STATES\n\nnodes_extinct_reverse=sort(nodes_extinct,decreasing=TRUE)\n            ancestral_states=c()\n            ancestors=c()\n            results=c()\n            results_rBLs=c()\n            results_branchlength=c()\n            results_node_anc=c()\n            results_node_desc=c()\n\nfor(i in nodes_extinct_reverse) {\n        #calculating ancestral states\n            sister_species=which(phy.matrix$Anc==i)\n\n            X1=phy.matrix$Value[sister_species[1]]\n            X2=phy.matrix$Value[sister_species[2]]\n            AP_desc=AP$value[which(AP$nodes==i)]\n\n            BL1=phy.matrix$Length[sister_species[1]]\n            BL2=phy.matrix$Length[sister_species[2]]\n\n\n            S1=abs(abs(X1-X2)/mean(c(X1,X2)))\n            S2=abs(abs(X2-AP_desc)/mean(c(X2,AP_desc)))\n            S3=abs(abs(X1-AP_desc)/mean(c(X1,AP_desc)))\n            \n            T1=((S1+S3)-S2)/2\n            T2=((S1+S2)-S3)/2\n            T3=((S2+S3)-S1)/2\n\n            rBL1=T1*((BL1/(BL1+BL2))*2)\n            rBL2=T2*((BL2/(BL1+BL2))*2)\n\n\n\n            A=((X1/rBL1)+(X2/rBL2))/((1/rBL1)+(1/rBL2))\n\n        #Saving results\n\n            desc1=phy.matrix$Desc[sister_species[1]]\n            desc2=phy.matrix$Desc[sister_species[2]]\n\n            value_desc1=phy.matrix$Value[which(phy.matrix$Desc==desc1)]\n            value_desc2=phy.matrix$Value[which(phy.matrix$Desc==desc2)]\n\n            phy.matrix$Value[which(phy.matrix$Desc==i)]=A\n\n        #building results dataframe\n            results_node_anc=rbind(results_node_anc,i)\n            results_node_anc=rbind(results_node_anc,i)\n            results_node_desc=rbind(results_node_desc,desc1)\n            results_node_desc=rbind(results_node_desc,desc2)\n            results_rBLs=rbind(results_rBLs,rBL1)\n            results_rBLs=rbind(results_rBLs,rBL2)\n            results_branchlength=rbind(results_branchlength,BL1)\n            results_branchlength=rbind(results_branchlength,BL2)\n                                }\n\n      #'results' dataframe\n      results<-c()\n      results=cbind(results,results_node_anc)\n      results=cbind(results,results_node_desc)\n      results=cbind(results,results_branchlength)\n      results=cbind(results,results_rBLs)\n      colnames(results)=c(\"node_anc\",\"node_desc\",\"BL\",\"rBLs\")\n\n      #ancestors\n      results<-results[order(match(results[,2],phy.matrix[,2])),]\n      rownames(results)<-c(1:length(results[,1]))\n      results<-as.data.frame(results)\n\n      return(results)\n\n}\n",
    "created" : 1423075667193.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2017250223",
    "id" : "5FCC5EAA",
    "lastKnownWriteTime" : 1423413452,
    "path" : "~/Google Drive/Research Projects/CURRENT_Smaers R Package/Evomap_Github/R/ie.r",
    "project_path" : "R/ie.r",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}